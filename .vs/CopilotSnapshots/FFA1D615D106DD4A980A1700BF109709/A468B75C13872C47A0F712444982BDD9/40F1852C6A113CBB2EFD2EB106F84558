using System;
using ChatApp.Shared;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Threading;
using System.Threading.Tasks;
using System.Collections.Concurrent;

namespace ChatAppServer
{
    public class DatabaseManager
    {
        private readonly string _originalConnectionString;
        private string _connectionString;
        private static DatabaseManager? _instance;
        public static DatabaseManager Instance => _instance ??= new DatabaseManager();

        private bool _messagesTableExists = true; // assume true until checked

        // lightweight in-memory user cache to allow login when DB is temporarily unavailable
        private readonly ConcurrentDictionary<string, CachedUser> _userCache = new ConcurrentDictionary<string, CachedUser>(StringComparer.OrdinalIgnoreCase);
        private volatile bool _dbAvailable = false;
        private readonly CancellationTokenSource _cts = new CancellationTokenSource();

        // Queue for pending online status updates to avoid blocking during login when DB is slow
        private readonly ConcurrentQueue<(string Username, bool IsOnline)> _pendingStatusUpdates = new ConcurrentQueue<(string, bool)>();
        private readonly SemaphoreSlim _pendingStatusSignal = new SemaphoreSlim(0);

        private class CachedUser
        {
            public string Username { get; set; } = string.Empty;
            public string DisplayName { get; set; } = string.Empty;
            public string Password { get; set; } = string.Empty; // hashed or plain as stored
        }

        private DatabaseManager()
        {
            _originalConnectionString = AppConfig.GetConnectionString("ChatAppDB");
            _connectionString = _originalConnectionString;

            // Configure connection string for fast failure initially and enable MARS/pool
            try
            {
                var builder = new SqlConnectionStringBuilder(_connectionString);
                // fail fast on connect so server doesn't block long on startup/login
                if (builder.ConnectTimeout > 5) builder.ConnectTimeout = 5;
                builder.MultipleActiveResultSets = true;
                builder.MaxPoolSize = Math.Max(builder.MaxPoolSize, 200);
                _connectionString = builder.ConnectionString;
                Logger.Info($"[DatabaseManager] Initialized with fast ConnectTimeout={builder.ConnectTimeout}s, MARS={builder.MultipleActiveResultSets}, MaxPoolSize={builder.MaxPoolSize}");
            }
            catch (Exception ex)
            {
                Logger.Warning($"[DatabaseManager] Could not adjust connection string: {ex.Message}");
            }

            // Start background loader to populate user cache and monitor DB availability
            Task.Run(() => UserCacheLoop(_cts.Token));

            // Start background worker to flush pending status updates
            Task.Run(() => ProcessPendingStatusUpdates(_cts.Token));

            // Seed fallback test accounts so app can be used while DB is unreachable
            SeedFallbackTestAccounts();
        }

        // Seed a small set of test users consistent with provided DB setup
        private void SeedFallbackTestAccounts()
        {
            // Only seed if cache is empty
            if (_userCache.Count > 0) return;

            var testAccounts = new List<CachedUser>
            {
                new CachedUser { Username = "user1", DisplayName = "Bạn Bè A", Password = "123" },
                new CachedUser { Username = "user2", DisplayName = "Bạn Bè B", Password = "123" },
                new CachedUser { Username = "user3", DisplayName = "Bạn Bè C", Password = "123" },
                new CachedUser { Username = "user5", DisplayName = "Bạn Bè D", Password = "123" },
                new CachedUser { Username = "admin", DisplayName = "Quản Trị Viên", Password = "admin" },
                new CachedUser { Username = "test1", DisplayName = "Người Dùng Test 1", Password = "test123" },
                new CachedUser { Username = "test2", DisplayName = "Người Dùng Test 2", Password = "test123" },
                new CachedUser { Username = "huyphuoc", DisplayName = "Huy Phước", Password = "123" },
                new CachedUser { Username = "huyphuoc1", DisplayName = "Huy Phước 1", Password = "123123" }
            };

            foreach (var acc in testAccounts)
            {
                _userCache[acc.Username] = acc;
            }

            Logger.Info($"[DatabaseManager] Seeded {_userCache.Count} fallback test accounts into cache.");
        }

        private async Task UserCacheLoop(CancellationToken ct)
        {
            while (!ct.IsCancellationRequested)
            {
                try
                {
                    bool loaded = await TryLoadUsersToCacheAsync();
                    _dbAvailable = loaded;

                    // if DB available, increase connect timeout for normal ops
                    if (loaded)
                    {
                        try
                        {
                            var builder = new SqlConnectionStringBuilder(_originalConnectionString);
                            if (builder.ConnectTimeout < 30) builder.ConnectTimeout = 30;
                            builder.MultipleActiveResultSets = true;
                            builder.MaxPoolSize = Math.Max(builder.MaxPoolSize, 200);
                            _connectionString = builder.ConnectionString;
                        }
                        catch { /* ignore */ }

                        // Wait longer when DB is healthy
                        await Task.Delay(TimeSpan.FromSeconds(15), ct);
                    }
                    else
                    {
                        // Retry sooner when DB is down
                        await Task.Delay(TimeSpan.FromSeconds(5), ct);
                    }
                }
                catch (TaskCanceledException) { break; }
                catch (Exception ex)
                {
                    Logger.Warning($"[DatabaseManager] UserCacheLoop error: {ex.Message}");
                    await Task.Delay(5000, ct);
                }
            }
        }

        private async Task<bool> TryLoadUsersToCacheAsync()
        {
            try
            {
                var users = new List<CachedUser>();
                using (SqlConnection conn = new SqlConnection(_connectionString))
                {
                    // short open timeout already set on connection string
                    await conn.OpenAsync();
                    using (SqlCommand cmd = new SqlCommand("SELECT Username, DisplayName, Password FROM Users", conn))
                    {
                        cmd.CommandTimeout = 10;
                        using (var reader = await cmd.ExecuteReaderAsync())
                        {
                            while (await reader.ReadAsync())
                            {
                                users.Add(new CachedUser
                                {
                                    Username = reader["Username"]?.ToString() ?? string.Empty,
                                    DisplayName = reader["DisplayName"]?.ToString() ?? string.Empty,
                                    Password = reader["Password"]?.ToString() ?? string.Empty
                                });
                            }
                        }
                    }
                }

                // update cache atomically
                var newCache = new ConcurrentDictionary<string, CachedUser>(StringComparer.OrdinalIgnoreCase);
                foreach (var u in users)
                {
                    if (!string.IsNullOrEmpty(u.Username)) newCache[u.Username] = u;
                }

                _userCache.Clear();
                foreach (var kv in newCache) _userCache[kv.Key] = kv.Value;

                Logger.Info($"[DatabaseManager] Loaded {_userCache.Count} users into cache.");
                return true;
            }
            catch (Exception ex)
            {
                Logger.Warning($"[DatabaseManager] Unable to load users for cache: {ex.Message}");
                return false;
            }
        }

        // Return true if Messages table exists (do not create tables at runtime for production DB)
        private bool EnsureMessagesTableExists()
        {
            try
            {
                using (SqlConnection conn = new SqlConnection(_connectionString))
                {
                    conn.Open();
                    string checkSql = "SELECT OBJECT_ID('dbo.Messages','U')";
                    using (SqlCommand cmd = new SqlCommand(checkSql, conn))
                    {
                        object obj = cmd.ExecuteScalar();
                        return (obj != null && obj != DBNull.Value);
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.Warning($"[EnsureMessagesTableExists] Error checking Messages table existence: {ex.Message}");
                return false;
            }
        }

        // New: update user's online flag and LastSeen
        public void UpdateUserOnlineStatus(string username, bool isOnline)
        {
            try
            {
                // Enqueue request and return immediately so login/register flows are not blocked by slow DB
                _pendingStatusUpdates.Enqueue((username, isOnline));
                _pendingStatusSignal.Release();
            }
            catch (Exception ex)
            {
                Logger.Warning($"[UpdateUserOnlineStatus] Failed to enqueue status for {username}: {ex.Message}");
            }

            // update cache if present
            if (_userCache.TryGetValue(username, out var cached))
            {
                // nothing to change except maybe last seen not stored in cache
                _userCache[username] = cached;
            }
        }

        // Background worker to process pending status updates with short connect timeout and retries
        private async Task ProcessPendingStatusUpdates(CancellationToken ct)
        {
            while (!ct.IsCancellationRequested)
            {
                try
                {
                    await _pendingStatusSignal.WaitAsync(ct);
                }
                catch (OperationCanceledException) { break; }

                // Dequeue and process all available items
                while (_pendingStatusUpdates.TryDequeue(out var item))
                {
                    string username = item.Username;
                    bool isOnline = item.IsOnline;

                    bool success = false;
                    int attempts = 0;

                    while (!success && attempts < 3 && !ct.IsCancellationRequested)
                    {
                        attempts++;
                        try
                        {
                            // Use a very short connect timeout for these opportunistic updates
                            var builder = new SqlConnectionStringBuilder(_originalConnectionString)
                            {
                                ConnectTimeout = 3,
                                MultipleActiveResultSets = true
                            };
                            builder.MaxPoolSize = Math.Max(builder.MaxPoolSize, 200);
                            string fastConn = builder.ConnectionString;

                            using (SqlConnection conn = new SqlConnection(fastConn))
                            {
                                // prefer async open when possible
                                await conn.OpenAsync(ct).ConfigureAwait(false);

                                string query = isOnline
                                    ? "UPDATE Users SET IsOnline = 1 WHERE Username = @u"
                                    : "UPDATE Users SET IsOnline = 0, LastSeen = GETDATE() WHERE Username = @u";

                                using (SqlCommand cmd = new SqlCommand(query, conn))
                                {
                                    cmd.Parameters.AddWithValue("@u", username);
                                    await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
                                }
                            }

                            success = true;
                        }
                        catch (OperationCanceledException) { break; }
                        catch (SqlException sqlEx)
                        {
                            // Handle missing IsOnline column gracefully: fall back to updating LastSeen for offline events
                            if (sqlEx.Message != null && sqlEx.Message.Contains("Invalid column name 'IsOnline'"))
                            {
                                try
                                {
                                    // If column doesn't exist, do a safe fallback: set LastSeen for offline events only
                                    if (!isOnline)
                                    {
                                        var builder = new SqlConnectionStringBuilder(_originalConnectionString)
                                        {
                                            ConnectTimeout = 3,
                                            MultipleActiveResultSets = true
                                        };
                                        builder.MaxPoolSize = Math.Max(builder.MaxPoolSize, 200);
                                        string fastConn = builder.ConnectionString;

                                        using (SqlConnection conn = new SqlConnection(fastConn))
                                        {
                                            await conn.OpenAsync(ct).ConfigureAwait(false);
                                            string fallbackQuery = "UPDATE Users SET LastSeen = GETDATE() WHERE Username = @u";
                                            using (SqlCommand cmd = new SqlCommand(fallbackQuery, conn))
                                            {
                                                cmd.Parameters.AddWithValue("@u", username);
                                                await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
                                            }
                                        }
                                    }
                                    // Treat as success to avoid infinite retries
                                    success = true;
                                    break;
                                }
                                catch (Exception ex)
                                {
                                    Logger.Warning($"[ProcessPendingStatusUpdates] Fallback update failed for {username}: {ex.Message}");
                                    // Continue to retry the outer loop
                                }
                            }

                            // If it fails, wait a bit and retry; also log once per attempt
                            Logger.Warning($"[ProcessPendingStatusUpdates] Attempt {attempts} failed for {username}: {sqlEx.Message}");

                            // small backoff
                            try { await Task.Delay(1000 * attempts, ct).ConfigureAwait(false); } catch { }
                        }
                        catch (Exception ex)
                        {
                            // If it fails, wait a bit and retry; also log once per attempt
                            Logger.Warning($"[ProcessPendingStatusUpdates] Attempt {attempts} failed for {username}: {ex.Message}");

                            // small backoff
                            try { await Task.Delay(1000 * attempts, ct).ConfigureAwait(false); } catch { }
                        }
                    }

                    if (!success)
                    {
                        // If still failed after retries, re-enqueue for later processing to avoid dropping status permanently
                        _pendingStatusUpdates.Enqueue((username, isOnline));
                        // avoid tight loop: delay before next background attempt
                        try { await Task.Delay(5000, ct).ConfigureAwait(false); } catch { }
                        // Signal to process again later
                        _pendingStatusSignal.Release();
                        // break to allow other work or cancellation to be observed
                        break;
                    }
                }
            }
        }

        // Hàm kiểm tra đăng nhập (hỗ trợ cả username và email) - với password hashing
        public UserData? Login(string usernameOrEmail, string password, bool useEmail = false)
        {
            // Try DB login if DB available; otherwise fallback to cache
            if (_dbAvailable)
            {
                try
                {
                    using (SqlConnection conn = new SqlConnection(_connectionString))
                    {
                        conn.Open();
                        string query = useEmail ? "SELECT Username, DisplayName, Password FROM Users WHERE Email = @u" : "SELECT Username, DisplayName, Password FROM Users WHERE Username = @u";

                        string? storedPassword = null;
                        string username = "";
                        string displayName = "";
                        bool needToHashPassword = false;
                        bool passwordValid = false;

                        using (SqlCommand cmd = new SqlCommand(query, conn))
                        {
                            cmd.CommandTimeout = 30;
                            cmd.Parameters.AddWithValue("@u", usernameOrEmail);

                            using (SqlDataReader reader = cmd.ExecuteReader())
                            {
                                if (reader.Read())
                                {
                                    storedPassword = reader["Password"]?.ToString();
                                    username = reader["Username"]?.ToString() ?? "";
                                    displayName = reader["DisplayName"]?.ToString() ?? "";

                                    if (string.IsNullOrEmpty(storedPassword))
                                    {
                                        Logger.Warning($"[Login] Password trong database rỗng cho user: {username}");
                                        return null;
                                    }
                                }
                                else
                                {
                                    Logger.Warning($"[Login] Không tìm thấy user: {usernameOrEmail}");
                                    return null;
                                }
                            }
                        }

                        storedPassword = storedPassword?.Trim();
                        password = password.Trim();

                        if (storedPassword == null) return null;

                        if (storedPassword.Contains(":"))
                        {
                            passwordValid = PasswordHelper.Ver