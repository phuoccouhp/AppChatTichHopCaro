using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Sockets;

namespace ChatAppServer
{
    /// <summary>
    /// Helper class để mở port trên Windows Firewall và kiểm tra kết nối mạng
    /// </summary>
    public static class FirewallHelper
    {
        /// <summary>
        /// Mở port trên Windows Firewall cho cả Inbound và Outbound trên TẤT CẢ PROFILES
        /// (Thường không thành công trừ khi chạy với quyền Admin - sử dụng OpenPortAsAdmin thay thế)
        /// </summary>
        public static bool OpenPort(int port, string ruleName = "ChatAppServer")
        {
            try
            {
                Logger.Warning("[OpenPort] This method usually requires admin privileges. Use OpenPortAsAdmin() for better results.");

                // Xóa rule cũ trước (cần admin)
                RunNetshCommand($"advfirewall firewall delete rule name=\"{ruleName}\"");
                RunNetshCommand($"advfirewall firewall delete rule name=\"{ruleName} (Out)\"");

                // Tạo Inbound Rule cho TẤT CẢ PROFILES (Domain, Private, Public)
                string inboundResult = RunNetshCommand(
                    $"advfirewall firewall add rule name=\"{ruleName}\" " +
                    $"dir=in action=allow protocol=TCP localport={port} " +
                    $"profile=domain,private,public enable=yes");

                Logger.Info($"[Firewall] Inbound rule creation result: {inboundResult.Substring(0, Math.Min(100, inboundResult.Length))}");

                // Tạo Outbound Rule cho TẤT CẢ PROFILES
                // WARNING: netsh có vấn đề với rule name chứa parentheses - tốt nhất là sử dụng PowerShell
                string outboundResult = RunNetshCommand(
                    $"advfirewall firewall add rule name=\"{ruleName} (Out)\" " +
                    $"dir=out action=allow protocol=TCP localport={port} remoteip=any " +
                    $"profile=domain,private,public enable=yes");

                Logger.Info($"[Firewall] Outbound rule creation result: {outboundResult.Substring(0, Math.Min(100, outboundResult.Length))}");

                if (outboundResult.Contains("The object already exists") || outboundResult.Contains("successfully"))
                {
                    Logger.Success($"✓ Đã mở port {port} trên Windows Firewall cho TẤT CẢ PROFILES (Domain, Private, Public)");
                    return true;
                }
                else
                {
                    Logger.Warning($"⚠️ Outbound rule creation may have failed. Output: {outboundResult}");
                    Logger.Warning("[OpenPort] Recommend using OpenPortAsAdmin() instead");
                    return false;
                }
            }
            catch (Exception ex)
            {
                Logger.Error($"Lỗi khi mở port {port} trên Firewall", ex);
                return false;
            }
        }

        private static bool ParseNetshEnabledFlag(string netshOutput)
        {
            if (string.IsNullOrEmpty(netshOutput))
            {
                Logger.Info("[ParseNetshEnabledFlag] Empty netsh output");
                return false;
            }
            
            // Log the full output for debugging
            Logger.Info($"[ParseNetshEnabledFlag] Netsh output length: {netshOutput.Length} chars");
            
            // Kiểm tra xem rule có tồn tại không (Rule Name là dấu hiệu rule tồn tại)
            bool hasRuleName = netshOutput.Contains("Rule Name") || 
                               netshOutput.Contains("Tên quy tắc") ||
                               netshOutput.Contains("RuleName");
            
            if (!hasRuleName)
            {
                Logger.Info("[ParseNetshEnabledFlag] Rule Name not found in output - rule may not exist");
                return false;
            }

            Logger.Info("[ParseNetshEnabledFlag] Rule Name found");

            // Kiểm tra enabled status - nhiều định dạng khác nhau
            if (netshOutput.Contains("Enabled: Yes") || netshOutput.Contains("Enabled:Yes"))
            {
                Logger.Info("[ParseNetshEnabledFlag] Match: Enabled: Yes");
                return true;
            }
            
            if (netshOutput.Contains("Đã bật") || netshOutput.Contains("Enabled: Có"))
            {
                Logger.Info("[ParseNetshEnabledFlag] Match: Enabled (Vietnamese)");
                return true;
            }
            
            if (netshOutput.Contains("Enabled") && netshOutput.Contains("Yes"))
            {
                Logger.Info("[ParseNetshEnabledFlag] Match: Enabled + Yes");
                return true;
            }
            
            // Nếu rule tồn tại và action=allow, thì coi như enabled
            if (netshOutput.Contains("Action: Allow") || 
                netshOutput.Contains("Hành động: Cho phép") ||
                netshOutput.Contains("Action:Allow"))
            {
                Logger.Info("[ParseNetshEnabledFlag] Match: Action: Allow (rule exists and allows traffic)");
                return true;
            }

            // Fallback: nếu rule name tồn tại nhưng không tìm thấy explicit enabled flag
            // Log toàn bộ output để debug
            Logger.Warning($"[ParseNetshEnabledFlag] Rule exists but cannot determine enabled status. Output:\n{netshOutput}");
            return false;
        }

        private static bool IsPowerShellAvailable()
        {
            try
            {
                var psi = new ProcessStartInfo
                {
                    FileName = "powershell",
                    Arguments = "-Command \"$PSVersionTable.PSVersion\"",
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    CreateNoWindow = true
                };
                using (var p = Process.Start(psi))
                {
                    if (p == null) return false;
                    string outp = p.StandardOutput.ReadToEnd();
                    p.WaitForExit(1000);
                }
                return true;
            }
            catch { return false; }
        }

        private static bool QueryFirewallRuleEnabledWithPowerShell(string ruleName, bool inbound)
        {
            try
            {
                // Use Get-NetFirewallRule (requires admin) to test rule state
                string direction = inbound ? "Inbound" : "Outbound";
                string ps = $"(Get-NetFirewallRule -DisplayName \"{ruleName}\" -ErrorAction SilentlyContinue) | Select-Object -First 1 | ForEach-Object {{ $_.Enabled -eq 'True' }}";
                var psi = new ProcessStartInfo
                {
                    FileName = "powershell",
                    Arguments = $"-NoProfile -Command \"{ps}\"",
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    CreateNoWindow = true
                };
                using (var p = Process.Start(psi))
                {
                    if (p == null) return false;
                    string outp = p.StandardOutput.ReadToEnd();
                    string err = p.StandardError.ReadToEnd();
                    p.WaitForExit(2000);
                    if (!string.IsNullOrEmpty(err)) return false;
                    return outp.Trim().Equals("True", StringComparison.OrdinalIgnoreCase);
                }
            }
            catch
            {
                return false;
            }
        } // <--- ĐÃ SỬA: Xóa bỏ khối catch thừa thãi và biến 'port' không tồn tại

        /// <summary>
        /// Kiểm tra xem rule đã tồn tại và được enable chưa
        /// </summary>
        public static bool IsPortOpen(int port, string ruleName = "ChatAppServer", int retryCount = 1, int delayMs = 0)
        {
            for (int attempt = 0; attempt < retryCount; attempt++)
            {
                try
                {
                    // Kiểm tra inbound rule
                    string inboundResult = RunNetshCommand($"advfirewall firewall show rule name=\"{ruleName}\" dir=in");
                    Logger.Info($"[IsPortOpen] Inbound netsh output: {inboundResult.Length} chars");

                    // Kiểm tra outbound rule
                    string outboundRuleName = $"{ruleName} (Out)";
                    string outboundResult = RunNetshCommand($"advfirewall firewall show rule name=\"{outboundRuleName}\" dir=out");
                    Logger.Info($"[IsPortOpen] Outbound netsh output: {outboundResult.Length} chars");

                    // Parse enabled state more robustly (netsh output may vary by language)
                    bool inboundExists = ParseNetshEnabledFlag(inboundResult);
                    bool outboundExists = ParseNetshEnabledFlag(outboundResult);

                    // Fallback: try PowerShell query if netsh output didn't show enabled rules
                    if ((!inboundExists || !outboundExists) && IsPowerShellAvailable())
                    {
                        Logger.Info("[IsPortOpen] Trying PowerShell fallback...");
                        try
                        {
                            if (!inboundExists)
                            {
                                inboundExists = QueryFirewallRuleEnabledWithPowerShell(ruleName, true);
                                Logger.Info($"[IsPortOpen] PowerShell inbound check: {inboundExists}");
                            }
                            if (!outboundExists)
                            {
                                outboundExists = QueryFirewallRuleEnabledWithPowerShell(outboundRuleName, false);
                                Logger.Info($"[IsPortOpen] PowerShell outbound check: {outboundExists}");
                            }
                        }
                        catch (Exception ex) 
                        { 
                            Logger.Warning($"[IsPortOpen] PowerShell fallback error: {ex.Message}");
                        }
                    }

                    if (!inboundExists || !outboundExists)
                    {
                        Logger.Info($"[IsPortOpen] Attempt {attempt + 1}/{retryCount}: Inbound={inboundExists}, Outbound={outboundExists}");
                    }

                    if (inboundExists && outboundExists)
                    {
                        Logger.Success($"✓ Firewall rules verified: Port {port} is OPEN");
                        return true;
                    }
                    else if (inboundExists && !outboundExists)
                    {
                        Logger.Warning($"⚠️ Inbound OK, Outbound MISSING. Client có thể gửi đến nhưng Server không trả lời được.");
                        
                        // Log raw netsh output for debugging
                        if (!string.IsNullOrEmpty(outboundResult))
                        {
                            Logger.Info($"[DEBUG] Raw outbound netsh output:\n{outboundResult}");
                        }
                        else
                        {
                            Logger.Warning("[DEBUG] Outbound netsh returned empty output");
                        }
                    }

                    if (attempt < retryCount - 1 && delayMs > 0)
                    {
                        Logger.Info($"[IsPortOpen] Waiting {delayMs}ms before retry...");
                        System.Threading.Thread.Sleep(delayMs);
                    }
                }
                catch (Exception ex)
                {
                    Logger.Warning($"Lỗi kiểm tra firewall (lần {attempt + 1}): {ex.Message}");
                }
            }

            return false;
        }

        private static string RunNetshCommand(string arguments)
        {
            try
            {
                ProcessStartInfo psi = new ProcessStartInfo
                {
                    FileName = "netsh",
                    Arguments = arguments,
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    CreateNoWindow = true,
                    WindowStyle = ProcessWindowStyle.Hidden
                };

                using (Process process = new Process())
                {
                    process.StartInfo = psi;
                    process.Start();

                    string output = process.StandardOutput.ReadToEnd();
                    string error = process.StandardError.ReadToEnd();

                    bool finished = process.WaitForExit(5000);

                    if (!finished)
                    {
                        try { process.Kill(); } catch { }
                        return "";
                    }

                    if (!string.IsNullOrEmpty(output) && (output.Contains("not valid") || output.Contains("Error")))
                    {
                        Logger.Info($"[Netsh Output] {output.Trim()}");
                    }

                    return output;
                }
            }
            catch
            {
                return "";
            }
        }

        /// <summary>
        /// Mở port với quyền Admin bằng PowerShell - Phiên bản đơn giản hóa
        /// Tạo rules cho TẤT CẢ PROFILES: Domain, Private, Public
        /// </summary>
        public static bool OpenPortAsAdmin(int port, string ruleName = "ChatAppServer")
        {
            string tempPsFile = null;
            try
            {
                // Phiên bản đơn giản - tránh các vấn đề escaping
                string psContent = $@"
# Disable error stops để có thể tiếp tục khi 1 command fail
`$ErrorActionPreference = 'Continue'

Write-Host 'Opening Windows Firewall Port {port}'
Write-Host '=========================================='

# Delete old rules (silently ignore errors)
Write-Host '[1/3] Deleting old rules...'
Remove-NetFirewallRule -DisplayName '{ruleName}' -Direction Inbound -ErrorAction SilentlyContinue | Out-Null
Remove-NetFirewallRule -DisplayName '{ruleName} (Out)' -Direction Outbound -ErrorAction SilentlyContinue | Out-Null
Write-Host '    Done'

# Create INBOUND rule
Write-Host '[2/3] Adding INBOUND rule...'
try {{
    New-NetFirewallRule -DisplayName '{ruleName}' -Direction Inbound -Action Allow -Protocol TCP -LocalPort {port} -Profile Domain,Private,Public -Enabled `$true -ErrorAction Stop | Out-Null
    Write-Host '    ✓ Inbound rule created'
}} catch {{
    Write-Host '    ✗ ERROR creating inbound rule: ' + `$_.Exception.Message
    exit 1
}}

# Create OUTBOUND rule
Write-Host '[3/3] Adding OUTBOUND rule...'
try {{
    New-NetFirewallRule -DisplayName '{ruleName} (Out)' -Direction Outbound -Action Allow -Protocol TCP -LocalPort {port} -RemoteAddress Any -Profile Domain,Private,Public -Enabled `$true -ErrorAction Stop | Out-Null
    Write-Host '    ✓ Outbound rule created'
}} catch {{
    Write-Host '    ✗ ERROR creating outbound rule: ' + `$_.Exception.Message
    exit 1
}}

# Verify
Write-Host ''
Write-Host 'Verifying rules...'
`$inbound = Get-NetFirewallRule -DisplayName '{ruleName}' -Direction Inbound -ErrorAction SilentlyContinue
`$outbound = Get-NetFirewallRule -DisplayName '{ruleName} (Out)' -Direction Outbound -ErrorAction SilentlyContinue

if (`$inbound) {{ Write-Host '    ✓ Inbound: OK' }} else {{ Write-Host '    ✗ Inbound: MISSING' }}
if (`$outbound) {{ Write-Host '    ✓ Outbound: OK' }} else {{ Write-Host '    ✗ Outbound: MISSING' }}

Write-Host '=========================================='
Write-Host 'SUCCESS: Port {port} is now OPEN'
Write-Host '=========================================='
exit 0
";
                tempPsFile = Path.Combine(Path.GetTempPath(), $"open_firewall_{Guid.NewGuid().ToString("N").Substring(0, 8)}.ps1");
                File.WriteAllText(tempPsFile, psContent, System.Text.Encoding.UTF8);

                Logger.Info($"[OpenPortAsAdmin] Launching PowerShell: {tempPsFile}");

                ProcessStartInfo psi = new ProcessStartInfo
                {
                    FileName = "powershell.exe",
                    Arguments = $"-NoProfile -ExecutionPolicy Bypass -File \"{tempPsFile}\"",
                    UseShellExecute = true,
                    Verb = "runas",
                    CreateNoWindow = false,
                    WindowStyle = ProcessWindowStyle.Normal
                };

                Process? process = Process.Start(psi);
                if (process == null)
                {
                    Logger.Error("[OpenPortAsAdmin] Failed to start PowerShell process");
                    return false;
                }

                process.WaitForExit();
                int exitCode = process.ExitCode;
                Logger.Info($"[OpenPortAsAdmin] PowerShell exit code: {exitCode}");

                // Xóa file tạm
                try { System.Threading.Thread.Sleep(500); File.Delete(tempPsFile); } catch { }

                if (exitCode != 0)
                {
                    Logger.Error($"[OpenPortAsAdmin] PowerShell script failed (exit code {exitCode})");
                    return false;
                }

                // QUAN TRỌNG: Chờ Windows Firewall đồng bộ
                Logger.Info("[OpenPortAsAdmin] Waiting 3 seconds for Windows Firewall to sync...");
                System.Threading.Thread.Sleep(3000);

                // Verify lại
                bool verified = IsPortOpen(port, ruleName, retryCount: 5, delayMs: 500);
                if (verified)
                {
                    Logger.Success($"✓ Firewall port {port} successfully opened and verified!");
                    return true;
                }
                else
                {
                    Logger.Warning($"⚠️ Rules may have been created but verification failed. Manual check recommended.");
                    return true; // Vẫn return true vì rules có thể được tạo thành công
                }
            }
            catch (Exception ex)
            {
                Logger.Error($"OpenPortAsAdmin failed: {ex.Message}");
                try { if (tempPsFile != null) File.Delete(tempPsFile); } catch { }
                return false;
            }
        }

        public static (bool success, string message, int latencyMs) TestConnection(string ipAddress, int port, int timeoutMs = 5000)
        {
            var stopwatch = System.Diagnostics.Stopwatch.StartNew();
            try
            {
                using (TcpClient client = new TcpClient())
                {
                    var result = client.BeginConnect(ipAddress, port, null, null);
                    bool success = result.AsyncWaitHandle.WaitOne(timeoutMs);
                    stopwatch.Stop();

                    if (success && client.Connected)
                    {
                        client.EndConnect(result);
                        return (true, $"✓ Connection successful to {ipAddress}:{port}", (int)stopwatch.ElapsedMilliseconds);
                    }
                    else
                    {
                        return (false, $"✗ Cannot connect to {ipAddress}:{port} (Timeout)", (int)stopwatch.ElapsedMilliseconds);
                    }
                }
            }
            catch (Exception ex)
            {
                stopwatch.Stop();
                return (false, $"✗ Error: {ex.Message}", (int)stopwatch.ElapsedMilliseconds);
            }
        }

        public static (bool success, string message, int latencyMs) Ping(string ipAddress, int timeoutMs = 3000)
        {
            try
            {
                using (var ping = new System.Net.NetworkInformation.Ping())
                {
                    var reply = ping.Send(ipAddress, timeoutMs);
                    if (reply.Status == System.Net.NetworkInformation.IPStatus.Success)
                        return (true, $"✓ Ping successful ({reply.RoundtripTime}ms)", (int)reply.RoundtripTime);
                    else
                        return (false, $"✗ Ping failed: {reply.Status}", 0);
                }
            }
            catch (Exception ex)
            {
                return (false, $"✗ Ping error: {ex.Message}", 0);
            }
        }

        public static List<string> GetAllLocalIPs()
        {
            var ips = new List<string>();
            try
            {
                var host = Dns.GetHostEntry(Dns.GetHostName());
                foreach (var ip in host.AddressList)
                {
                    if (ip.AddressFamily == AddressFamily.InterNetwork)
                        ips.Add(ip.ToString());
                }
            }
            catch { }
            return ips;
        }

        public static bool IsPortInUse(int port)
        {
            try
            {
                using (TcpListener listener = new TcpListener(IPAddress.Loopback, port))
                {
                    listener.Start();
                    listener.Stop();
                    return false;
                }
            }
            catch (SocketException) { return true; }
        }

        public static bool IsPortListening(int port)
        {
            try
            {
                using (TcpClient client = new TcpClient())
                {
                    var result = client.BeginConnect(IPAddress.Loopback, port, null, null);
                    if (result.AsyncWaitHandle.WaitOne(2000) && client.Connected) return true;
                }
                return false;
            }
            catch { return false; }
        }
    }
}