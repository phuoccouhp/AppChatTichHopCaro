using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Sockets;

namespace ChatAppServer
{
    /// <summary>
    /// Helper class để mở port trên Windows Firewall và kiểm tra kết nối mạng
    /// </summary>
    public static class FirewallHelper
    {
        /// <summary>
        /// Mở port trên Windows Firewall cho cả Inbound và Outbound trên TẤT CẢ PROFILES
        /// </summary>
        public static bool OpenPort(int port, string ruleName = "ChatAppServer")
        {
            try
            {
                // Xóa rule cũ trước
                RunNetshCommand($"advfirewall firewall delete rule name=\"{ruleName}\"");
                RunNetshCommand($"advfirewall firewall delete rule name=\"{ruleName} (Out)\"");

                // Tạo Inbound Rule cho TẤT CẢ PROFILES (Domain, Private, Public)
                string inboundResult = RunNetshCommand(
                    $"advfirewall firewall add rule name=\"{ruleName}\" " +
                    $"dir=in action=allow protocol=TCP localport={port} " +
                    $"profile=domain,private,public enable=yes");

                Logger.Info($"[Firewall] Inbound rule creation result: {inboundResult}");

                // Tạo Outbound Rule cho TẤT CẢ PROFILES
                string outboundResult = RunNetshCommand(
                    $"advfirewall firewall add rule name=\"{ruleName} (Out)\" " +
                    $"dir=out action=allow protocol=TCP localport={port} " +
                    $"profile=domain,private,public enable=yes");

                Logger.Info($"[Firewall] Outbound rule creation result: {outboundResult}");

                Logger.Success($"✓ Đã mở port {port} trên Windows Firewall cho TẤT CẢ PROFILES (Domain, Private, Public)");
                return true;
            }
            catch (Exception ex)
            {
                Logger.Error($"Lỗi khi mở port {port} trên Firewall", ex);
                return false;
            }
        } // <--- ĐÃ THÊM DẤU ĐÓNG NGOẶC BỊ THIẾU TẠI ĐÂY

        private static bool ParseNetshEnabledFlag(string netshOutput)
        {
            if (string.IsNullOrEmpty(netshOutput)) return false;
            // Look for Enabled: Yes (English) or Đã bật/Yes in other languages
            if (netshOutput.Contains("Enabled: Yes") || netshOutput.Contains("Enabled:Yes")) return true;
            if (netshOutput.Contains("Enabled") && netshOutput.Contains("Yes")) return true;
            if (netshOutput.Contains("Đã bật") || netshOutput.Contains("Enabled: Có")) return true;
            // Some versions include "Allow" or other markers; check for Rule Name presence
            if ((netshOutput.Contains("Rule Name") || netshOutput.Contains("Tên quy tắc")) && netshOutput.Contains("Action: Allow")) return true;
            return false;
        }

        private static bool IsPowerShellAvailable()
        {
            try
            {
                var psi = new ProcessStartInfo
                {
                    FileName = "powershell",
                    Arguments = "-Command \"$PSVersionTable.PSVersion\"",
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    CreateNoWindow = true
                };
                using (var p = Process.Start(psi))
                {
                    if (p == null) return false;
                    string outp = p.StandardOutput.ReadToEnd();
                    p.WaitForExit(1000);
                }
                return true;
            }
            catch { return false; }
        }

        private static bool QueryFirewallRuleEnabledWithPowerShell(string ruleName, bool inbound)
        {
            try
            {
                // Use Get-NetFirewallRule (requires admin) to test rule state
                string direction = inbound ? "Inbound" : "Outbound";
                string ps = $"(Get-NetFirewallRule -DisplayName \"{ruleName}\" -ErrorAction SilentlyContinue) | Select-Object -First 1 | ForEach-Object {{ $_.Enabled -eq 'True' }}";
                var psi = new ProcessStartInfo
                {
                    FileName = "powershell",
                    Arguments = $"-NoProfile -Command \"{ps}\"",
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    CreateNoWindow = true
                };
                using (var p = Process.Start(psi))
                {
                    if (p == null) return false;
                    string outp = p.StandardOutput.ReadToEnd();
                    string err = p.StandardError.ReadToEnd();
                    p.WaitForExit(2000);
                    if (!string.IsNullOrEmpty(err)) return false;
                    return outp.Trim().Equals("True", StringComparison.OrdinalIgnoreCase);
                }
            }
            catch
            {
                return false;
            }
        } // <--- ĐÃ SỬA: Xóa bỏ khối catch thừa thãi và biến 'port' không tồn tại

        /// <summary>
        /// Kiểm tra xem rule đã tồn tại và được enable chưa
        /// </summary>
        public static bool IsPortOpen(int port, string ruleName = "ChatAppServer", int retryCount = 1, int delayMs = 0)
        {
            for (int attempt = 0; attempt < retryCount; attempt++)
            {
                try
                {
                    // Kiểm tra inbound rule
                    string inboundResult = RunNetshCommand($"advfirewall firewall show rule name=\"{ruleName}\" dir=in");

                    // Kiểm tra outbound rule
                    string outboundRuleName = $"{ruleName} (Out)";
                    string outboundResult = RunNetshCommand($"advfirewall firewall show rule name=\"{outboundRuleName}\" dir=out");

                    // Parse enabled state more robustly (netsh output may vary by language)
                    bool inboundExists = ParseNetshEnabledFlag(inboundResult);
                    bool outboundExists = ParseNetshEnabledFlag(outboundResult);

                    // Fallback: try PowerShell query if netsh output didn't show enabled rules
                    if ((!inboundExists || !outboundExists) && IsPowerShellAvailable())
                    {
                        try
                        {
                            if (!inboundExists)
                                inboundExists = QueryFirewallRuleEnabledWithPowerShell(ruleName, true);
                            if (!outboundExists)
                                outboundExists = QueryFirewallRuleEnabledWithPowerShell(outboundRuleName, false);
                        }
                        catch { }
                    }

                    if (!inboundExists || !outboundExists)
                    {
                        Logger.Info($"[IsPortOpen] Attempt {attempt + 1}/{retryCount}: Inbound={inboundExists}, Outbound={outboundExists}");
                    }

                    if (inboundExists && outboundExists)
                    {
                        Logger.Success($"✓ Firewall rules verified: Port {port} is OPEN");
                        return true;
                    }
                    else if (inboundExists && !outboundExists)
                    {
                        Logger.Warning($"⚠️ Inbound OK, Outbound MISSING. Client có thể gửi đến nhưng Server không trả lời được.");
                    }

                    if (attempt < retryCount - 1 && delayMs > 0)
                    {
                        System.Threading.Thread.Sleep(delayMs);
                    }
                }
                catch (Exception ex)
                {
                    Logger.Warning($"Lỗi kiểm tra firewall (lần {attempt + 1}): {ex.Message}");
                }
            }

            return false;
        }

        private static string RunNetshCommand(string arguments)
        {
            try
            {
                ProcessStartInfo psi = new ProcessStartInfo
                {
                    FileName = "netsh",
                    Arguments = arguments,
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    CreateNoWindow = true,
                    WindowStyle = ProcessWindowStyle.Hidden
                };

                using (Process process = new Process())
                {
                    process.StartInfo = psi;
                    process.Start();

                    string output = process.StandardOutput.ReadToEnd();
                    string error = process.StandardError.ReadToEnd();

                    bool finished = process.WaitForExit(5000);

                    if (!finished)
                    {
                        try { process.Kill(); } catch { }
                        return "";
                    }

                    if (!string.IsNullOrEmpty(output) && (output.Contains("not valid") || output.Contains("Error")))
                    {
                        Logger.Info($"[Netsh Output] {output.Trim()}");
                    }

                    return output;
                }
            }
            catch
            {
                return "";
            }
        }

        /// <summary>
        /// Mở port với quyền Admin bằng file batch
        /// Tạo rules cho TẤT CẢ PROFILES: Domain, Private, Public
        /// </summary>
        public static bool OpenPortAsAdmin(int port, string ruleName = "ChatAppServer")
        {
            string tempBatchFile = null;
            try
            {
                // TẠO RULES CHO TẤT CẢ PROFILES (Domain, Private, Public)
                string batchContent = $@"@echo off
setlocal enabledelayedexpansion

echo ========================================
echo Opening Windows Firewall Port {port}
echo ========================================

echo [1/4] Deleting old rules...
netsh advfirewall firewall delete rule name=""{ruleName}"" >nul 2>&1
netsh advfirewall firewall delete rule name=""{ruleName} (Out)"" >nul 2>&1

echo [2/4] Adding INBOUND rule (Domain, Private, Public)...
netsh advfirewall firewall add rule name=""{ruleName}"" ^
    dir=in action=allow protocol=TCP localport={port} ^
    profile=domain,private,public enable=yes
if !errorlevel! neq 0 (
    echo ERROR: Inbound rule failed (!errorlevel!)
    exit /b 1
)

echo [3/4] Adding OUTBOUND rule (Domain, Private, Public)...
netsh advfirewall firewall add rule name=""{ruleName} (Out)"" ^
    dir=out action=allow protocol=TCP localport={port} ^
    profile=domain,private,public enable=yes
if !errorlevel! neq 0 (
    echo ERROR: Outbound rule failed (!errorlevel!)
    exit /b 1
)

echo [4/4] Verifying rules...
netsh advfirewall firewall show rule name=""{ruleName}"" dir=in
timeout /t 1 /nobreak >nul

echo ========================================
echo SUCCESS: Port {port} is now OPEN
echo ========================================
timeout /t 2 /nobreak >nul
exit /b 0
";
                tempBatchFile = Path.Combine(Path.GetTempPath(), $"open_firewall_{Guid.NewGuid().ToString("N").Substring(0, 8)}.bat");
                File.WriteAllText(tempBatchFile, batchContent, System.Text.Encoding.ASCII);

                Logger.Info($"[OpenPortAsAdmin] Launching batch script: {tempBatchFile}");

                ProcessStartInfo psi = new ProcessStartInfo
                {
                    FileName = tempBatchFile,
                    UseShellExecute = true,
                    Verb = "runas", // Yêu cầu quyền Admin
                    CreateNoWindow = false,
                    WindowStyle = ProcessWindowStyle.Normal
                };

                Process? process = Process.Start(psi);
                if (process == null) return false;

                process.WaitForExit();

                // Xóa file tạm
                try { System.Threading.Thread.Sleep(500); File.Delete(tempBatchFile); } catch { }

                // Verify lại
                bool verified = IsPortOpen(port, ruleName, retryCount: 3, delayMs: 1000);
                if (verified)
                {
                    Logger.Success($"✓ Firewall port {port} successfully opened and verified!");
                }
                else
                {
                    Logger.Warning($"⚠️ Firewall rule created but not verified. Please check Windows Firewall settings.");
                }
                return verified;
            }
            catch (Exception ex)
            {
                Logger.Error($"OpenPortAsAdmin Failed: {ex.Message}");
                return false;
            }
        }

        public static (bool success, string message, int latencyMs) TestConnection(string ipAddress, int port, int timeoutMs = 5000)
        {
            var stopwatch = System.Diagnostics.Stopwatch.StartNew();
            try
            {
                using (TcpClient client = new TcpClient())
                {
                    var result = client.BeginConnect(ipAddress, port, null, null);
                    bool success = result.AsyncWaitHandle.WaitOne(timeoutMs);
                    stopwatch.Stop();

                    if (success && client.Connected)
                    {
                        client.EndConnect(result);
                        return (true, $"✓ Connection successful to {ipAddress}:{port}", (int)stopwatch.ElapsedMilliseconds);
                    }
                    else
                    {
                        return (false, $"✗ Cannot connect to {ipAddress}:{port} (Timeout)", (int)stopwatch.ElapsedMilliseconds);
                    }
                }
            }
            catch (Exception ex)
            {
                stopwatch.Stop();
                return (false, $"✗ Error: {ex.Message}", (int)stopwatch.ElapsedMilliseconds);
            }
        }

        public static (bool success, string message, int latencyMs) Ping(string ipAddress, int timeoutMs = 3000)
        {
            try
            {
                using (var ping = new System.Net.NetworkInformation.Ping())
                {
                    var reply = ping.Send(ipAddress, timeoutMs);
                    if (reply.Status == System.Net.NetworkInformation.IPStatus.Success)
                        return (true, $"✓ Ping successful ({reply.RoundtripTime}ms)", (int)reply.RoundtripTime);
                    else
                        return (false, $"✗ Ping failed: {reply.Status}", 0);
                }
            }
            catch (Exception ex)
            {
                return (false, $"✗ Ping error: {ex.Message}", 0);
            }
        }

        public static List<string> GetAllLocalIPs()
        {
            var ips = new List<string>();
            try
            {
                var host = Dns.GetHostEntry(Dns.GetHostName());
                foreach (var ip in host.AddressList)
                {
                    if (ip.AddressFamily == AddressFamily.InterNetwork)
                        ips.Add(ip.ToString());
                }
            }
            catch { }
            return ips;
        }

        public static bool IsPortInUse(int port)
        {
            try
            {
                using (TcpListener listener = new TcpListener(IPAddress.Loopback, port))
                {
                    listener.Start();
                    listener.Stop();
                    return false;
                }
            }
            catch (SocketException) { return true; }
        }

        public static bool IsPortListening(int port)
        {
            try
            {
                using (TcpClient client = new TcpClient())
                {
                    var result = client.BeginConnect(IPAddress.Loopback, port, null, null);
                    if (result.AsyncWaitHandle.WaitOne(2000) && client.Connected) return true;
                }
                return false;
            }
            catch { return false; }
        }
    }
}