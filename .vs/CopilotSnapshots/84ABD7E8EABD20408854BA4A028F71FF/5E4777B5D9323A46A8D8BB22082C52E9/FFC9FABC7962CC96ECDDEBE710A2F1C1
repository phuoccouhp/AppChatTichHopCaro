using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Sockets;

namespace ChatAppServer
{
    /// <summary>
    /// Helper class ?? m? port trên Windows Firewall và ki?m tra k?t n?i m?ng
    /// </summary>
    public static class FirewallHelper
    {
        /// <summary>
        /// M? port v?i quy?n Administrator b?ng cách ch?y file batch
        /// </summary>
        public static bool OpenPortAsAdmin(int port, string ruleName = "ChatAppServer")
        {
            string tempBatchFile = null;
            try
            {
                // T?o file batch t?m th?i
                string batchContent = $@"@echo off
title Firewall Configuration
setlocal enabledelayedexpansion

echo.
echo ========================================
echo   Configuring Firewall for Port {port}
echo ========================================
echo.

REM Xóa rule c?
echo [1/3] Removing old rules...
netsh advfirewall firewall delete rule name=""{ruleName}"" >nul 2>&1
netsh advfirewall firewall delete rule name=""{ruleName} (Out)"" >nul 2>&1

REM T?o inbound rule
echo [2/3] Adding inbound rule...
netsh advfirewall firewall add rule name=""{ruleName}"" ^
    dir=in action=allow protocol=tcp localport={port} ^
    profile=private,domain enable=yes
if !ERRORLEVEL! NEQ 0 (
    echo ERROR: Failed to add inbound rule
    goto ERROR_EXIT
)

REM T?o outbound rule
echo [3/3] Adding outbound rule...
netsh advfirewall firewall add rule name=""{ruleName} (Out)"" ^
    dir=out action=allow protocol=tcp localport={port} ^
    profile=private,domain enable=yes
if !ERRORLEVEL! NEQ 0 (
    echo ERROR: Failed to add outbound rule
    goto ERROR_EXIT
)

echo.
echo ========================================
echo   SUCCESS! Port {port} is now open
echo ========================================
echo.
echo Firewall configuration complete.
echo You can close this window.
echo.
timeout /t 3 /nobreak
exit /b 0

:ERROR_EXIT
echo.
echo ERROR: Failed to configure firewall
echo.
timeout /t 5 /nobreak
exit /b 1
";
                tempBatchFile = Path.Combine(Path.GetTempPath(), $"fw_{Guid.NewGuid().ToString("N").Substring(0, 8)}.bat");
                File.WriteAllText(tempBatchFile, batchContent, System.Text.Encoding.ASCII);

                ProcessStartInfo psi = new ProcessStartInfo
                {
                    FileName = tempBatchFile,
                    UseShellExecute = true,
                    Verb = "runas",
                    CreateNoWindow = false,
                    WindowStyle = ProcessWindowStyle.Normal
                };

                Process? process = null;
                try
                {
                    process = Process.Start(psi);
                    if (process == null) 
                    {
                        Logger.Error("Failed to start firewall configuration process");
                        return false;
                    }

                    bool finished = process.WaitForExit(30000); // 30 seconds timeout
                    
                    if (!finished)
                    {
                        try { process.Kill(); } catch { }
                        Logger.Error("Firewall configuration timeout");
                        return false;
                    }

                    int exitCode = process.ExitCode;
                    
                    try 
                    { 
                        System.Threading.Thread.Sleep(1000);
                        File.Delete(tempBatchFile);
                        tempBatchFile = null;
                    } 
                    catch { }
                    
                    if (exitCode == 0)
                    {
                        Logger.Success($"? Port {port} firewall rules created successfully!");
                        System.Threading.Thread.Sleep(1500); // Wait for firewall to commit
                        return true;
                    }
                    else
                    {
                        Logger.Error($"? Firewall configuration failed (exit code: {exitCode})");
                        return false;
                    }
                }
                finally
                {
                    process?.Dispose();
                    if (tempBatchFile != null)
                    {
                        try 
                        { 
                            System.Threading.Thread.Sleep(1000);
                            File.Delete(tempBatchFile); 
                        } 
                        catch { }
                    }
                }
            }
            catch (System.ComponentModel.Win32Exception ex) when (ex.NativeErrorCode == 1223)
            {
                Logger.Warning("? Administrator access denied (UAC cancelled by user)");
                try { if (tempBatchFile != null) File.Delete(tempBatchFile); } catch { }
                return false;
            }
            catch (Exception ex)
            {
                Logger.Error($"Firewall configuration error: {ex.Message}");
                try { if (tempBatchFile != null) File.Delete(tempBatchFile); } catch { }
                return false;
            }
        }

        /// <summary>
        /// Ki?m tra xem rule ?ã t?n t?i ch?a
        /// </summary>
        public static bool IsPortOpen(int port, string ruleName = "ChatAppServer")
        {
            try
            {
                // Ki?m tra inbound rule
                string inboundResult = RunNetshCommand($"advfirewall firewall show rule name=\"{ruleName}\" dir=in");
                
                // Ki?m tra outbound rule
                string outboundResult = RunNetshCommand($"advfirewall firewall show rule name=\"{ruleName} (Out)\" dir=out");
                
                bool inboundExists = !string.IsNullOrEmpty(inboundResult) && 
                    (inboundResult.Contains("Rule Name") || inboundResult.Contains("Tên quy t?c"));
                
                bool outboundExists = !string.IsNullOrEmpty(outboundResult) && 
                    (outboundResult.Contains("Rule Name") || outboundResult.Contains("Tên quy t?c"));
                
                if (inboundExists && outboundExists)
                {
                    Logger.Success($"? Firewall rules for port {port} exist");
                    return true;
                }
                
                return false;
            }
            catch (Exception ex)
            {
                Logger.Warning($"Error checking firewall rules: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// Ch?y l?nh netsh
        /// </summary>
        private static string RunNetshCommand(string arguments)
        {
            try
            {
                ProcessStartInfo psi = new ProcessStartInfo
                {
                    FileName = "netsh",
                    Arguments = arguments,
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    CreateNoWindow = true,
                    WindowStyle = ProcessWindowStyle.Hidden
                };

                using (Process process = new Process())
                {
                    process.StartInfo = psi;
                    process.Start();
                    
                    string output = process.StandardOutput.ReadToEnd();
                    bool finished = process.WaitForExit(5000);
                    
                    if (!finished)
                    {
                        try { process.Kill(); } catch { }
                        return "";
                    }
                    
                    return output;
                }
            }
            catch (Exception ex)
            {
                Logger.Warning($"Netsh command error: {ex.Message}");
                return "";
            }
        }

        /// <summary>
        /// Test k?t n?i ??n m?t ??a ch? IP:Port
        /// </summary>
        public static (bool success, string message, int latencyMs) TestConnection(string ipAddress, int port, int timeoutMs = 5000)
        {
            var stopwatch = System.Diagnostics.Stopwatch.StartNew();
            try
            {
                using (TcpClient client = new TcpClient())
                {
                    var result = client.BeginConnect(ipAddress, port, null, null);
                    bool success = result.AsyncWaitHandle.WaitOne(timeoutMs);
                    stopwatch.Stop();

                    if (success && client.Connected)
                    {
                        client.EndConnect(result);
                        return (true, $"Connection successful", (int)stopwatch.ElapsedMilliseconds);
                    }
                    else
                    {
                        return (false, $"Connection timeout", (int)stopwatch.ElapsedMilliseconds);
                    }
                }
            }
            catch (SocketException ex)
            {
                stopwatch.Stop();
                string errorMsg = ex.SocketErrorCode switch
                {
                    SocketError.ConnectionRefused => "Port closed or no service listening",
                    SocketError.TimedOut => "Connection timeout",
                    SocketError.NetworkUnreachable => "Network unreachable",
                    SocketError.HostUnreachable => "Host unreachable",
                    _ => $"Socket error: {ex.SocketErrorCode}"
                };
                return (false, errorMsg, (int)stopwatch.ElapsedMilliseconds);
            }
            catch (Exception ex)
            {
                stopwatch.Stop();
                return (false, $"Error: {ex.Message}", (int)stopwatch.ElapsedMilliseconds);
            }
        }

        /// <summary>
        /// Ping ??n m?t ??a ch? IP
        /// </summary>
        public static (bool success, string message, int latencyMs) Ping(string ipAddress, int timeoutMs = 3000)
        {
            try
            {
                using (var ping = new System.Net.NetworkInformation.Ping())
                {
                    var reply = ping.Send(ipAddress, timeoutMs);
                    if (reply.Status == System.Net.NetworkInformation.IPStatus.Success)
                    {
                        return (true, $"Ping successful ({reply.RoundtripTime}ms)", (int)reply.RoundtripTime);
                    }
                    else
                    {
                        return (false, $"Ping failed: {reply.Status}", 0);
                    }
                }
            }
            catch (Exception ex)
            {
                return (false, $"Ping error: {ex.Message}", 0);
            }
        }

        /// <summary>
        /// L?y t?t c? ??a ch? IP c?a máy
        /// </summary>
        public static List<string> GetAllLocalIPs()
        {
            var ips = new List<string>();
            try
            {
                var host = Dns.GetHostEntry(Dns.GetHostName());
                foreach (var ip in host.AddressList)
                {
                    if (ip.AddressFamily == AddressFamily.InterNetwork)
                    {
                        ips.Add(ip.ToString());
                    }
                }
            }
            catch { }
            return ips;
        }

        /// <summary>
        /// Ki?m tra xem port có ?ang ???c s? d?ng không
        /// </summary>
        public static bool IsPortInUse(int port)
        {
            try
            {
                using (TcpListener listener = new TcpListener(IPAddress.Loopback, port))
                {
                    listener.Start();
                    listener.Stop();
                    return false;
                }
            }
            catch (SocketException)
            {
                return true;
            }
        }

        /// <summary>
        /// Ki?m tra xem port có ?ang l?ng nghe không
        /// </summary>
        public static bool IsPortListening(int port)
        {
            try
            {
                using (TcpClient client = new TcpClient())
                {
                    try
                    {
                        var result = client.BeginConnect(IPAddress.Loopback, port, null, null);
                        bool success = result.AsyncWaitHandle.WaitOne(2000);
                        
                        if (success && client.Connected)
                        {
                            client.EndConnect(result);
                            return true;
                        }
                    }
                    catch (SocketException sockEx)
                    {
                        if (sockEx.SocketErrorCode == SocketError.ConnectionRefused)
                        {
                            return false;
                        }
                    }
                }
                
                return false;
            }
            catch (Exception ex)
            {
                Logger.Warning($"Error checking port: {ex.Message}");
                return false;
            }
        }
    }
}
