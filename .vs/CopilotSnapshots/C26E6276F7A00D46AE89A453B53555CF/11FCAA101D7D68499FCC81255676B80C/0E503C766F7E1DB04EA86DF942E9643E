#pragma warning disable SYSLIB0011
using ChatApp.Shared;
using System;
using System.IO;
using System.Linq;
using System.Net.Sockets;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

namespace ChatAppServer
{
    public class ClientHandler
    {
        private TcpClient? _client;
        private Server _server;
        private NetworkStream? _stream;
        private JsonSerializerOptions _jsonOptions = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };

        public string? UserID { get; private set; }
        public string? UserName { get; private set; }
        public string ClientIP { get; private set; } = "Unknown";
        public DateTime LoginTime { get; private set; } = DateTime.Now;

        private string? _currentOtp = null;
        private string? _currentResetEmail = null;
        private DateTime? _otpCreatedTime = null;
        private const int OTP_VALID_MINUTES = 5; // OTP có hiệu lực trong 5 phút

        public ClientHandler(TcpClient client, Server server)
        {
            _client = client;
            _server = server;
            try
            {
                ClientIP = _client.Client.RemoteEndPoint?.ToString() ?? "Unknown";
                _stream = _client.GetStream();

                // Configure socket for stable cross-network connections (WiFi, LAN)
                _client.ReceiveBufferSize = 131072;
                _client.SendBufferSize = 131072;
                _client.NoDelay = true;
                
                // ✅ [FIX WiFi] Thiết lập timeout cho NetworkStream - QUAN TRỌNG cho kết nối qua mạng
                _stream.ReadTimeout = 120000;  // 2 phút - cho phép độ trễ cao của WiFi
                _stream.WriteTimeout = 60000;  // 1 phút

                // ✅ [FIX WiFi] Cấu hình TCP KeepAlive đầy đủ để duy trì kết nối qua NAT/Firewall
                try
                {
                    _client.Client.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.KeepAlive, true);
                    
                    // Cấu hình keepalive chi tiết cho Windows (thời gian tính bằng milliseconds)
                    // Byte 0-3: On/Off (1 = enable)
                    // Byte 4-7: KeepAliveTime (thời gian trước khi gửi probe đầu tiên) 
                    // Byte 8-11: KeepAliveInterval (thời gian giữa các probe)
                    byte[] keepAliveValues = new byte[12];
                    BitConverter.GetBytes((uint)1).CopyTo(keepAliveValues, 0);        // Enable
                    BitConverter.GetBytes((uint)30000).CopyTo(keepAliveValues, 4);    // 30 giây trước probe đầu
                    BitConverter.GetBytes((uint)5000).CopyTo(keepAliveValues, 8);     // 5 giây giữa các probe
                    _client.Client.IOControl(IOControlCode.KeepAliveValues, keepAliveValues, null);
                }
                catch (Exception kex)
                {
                    Logger.Warning($"[ClientHandler] Could not set keepalive options: {kex.Message}");
                }

                // Log new connection
                Logger.Info($"[CONNECT] New client connected: {ClientIP}");
            }
            catch (Exception ex)
            {
                Logger.Error("Error init handler", ex);
                Close();
            }
        }

        public async Task StartHandlingAsync()
        {
            if (_stream == null) return;
            byte[] lenBuf = new byte[4];
            int consecutiveTimeouts = 0;
            const int maxConsecutiveTimeouts = 5; // Server cho phép nhiều timeout hơn client

            while (_client != null && _client.Connected)
            {
                try
                {
                    // ✅ [FIX WiFi] Đọc với khả năng chịu lỗi tạm thời
                    int read = 0;
                    while (read < 4)
                    {
                        if (_stream == null || _client == null || !_client.Connected)
                            return;
                            
                        try
                        {
                            int r = await _stream.ReadAsync(lenBuf, read, 4 - read);
                            if (r == 0) return;
                            read += r;
                            consecutiveTimeouts = 0; // Reset khi đọc thành công
                        }
                        catch (IOException ioEx) when (ioEx.InnerException is SocketException sockEx && 
                            sockEx.SocketErrorCode == SocketError.TimedOut)
                        {
                            // ✅ [FIX WiFi] Cho phép timeout tạm thời - không ngắt kết nối ngay
                            consecutiveTimeouts++;
                            Logger.Warning($"[{ClientIP}] Read timeout ({consecutiveTimeouts}/{maxConsecutiveTimeouts})");
                            
                            if (consecutiveTimeouts >= maxConsecutiveTimeouts)
                            {
                                Logger.Warning($"[{ClientIP}] Too many timeouts, disconnecting");
                                return;
                            }
                            continue;
                        }
                    }
                    
                    int payloadLen = BitConverter.ToInt32(lenBuf, 0);

                    // ✅ Validate packet size
                    if (payloadLen <= 0 || payloadLen > 10 * 1024 * 1024)
                    {
                        Logger.Error($"[{ClientIP}] Invalid packet size: {payloadLen}");
                        return;
                    }

                    byte[] payload = new byte[payloadLen];
                    int offset = 0;
                    while (offset < payloadLen)
                    {
                        if (_stream == null || _client == null || !_client.Connected)
                            return;
                            
                        int r = await _stream.ReadAsync(payload, offset, payloadLen - offset);
                        if (r == 0) return;
                        offset += r;
                    }

                    string jsonString = Encoding.UTF8.GetString(payload);

                    // Log raw incoming payload (truncate long messages)
                    try
                    {
                        string snippet = jsonString.Length > 1000 ? jsonString.Substring(0, 1000) + "..." : jsonString;
                        Logger.Info($"[RECV RAW] {ClientIP}: {snippet}");
                    }
                    catch { }

                    PacketWrapper wrapper = null;
                    try
                    {
                        wrapper = JsonSerializer.Deserialize<PacketWrapper>(jsonString, _jsonOptions);
                    }
                    catch (Exception ex)
                    {
                        Logger.Error($"[DESERIALIZE ERROR] Failed to deserialize PacketWrapper from client {ClientIP}", ex);
                    }

                    if (wrapper == null)
                    {
                        Logger.Warning($"[WARNING] Received null or invalid PacketWrapper from {ClientIP}");
                        continue;
                    }

                    if (string.IsNullOrEmpty(wrapper.Type))
                    {
                        Logger.Warning($"[WARNING] PacketWrapper.Type empty from {ClientIP}");
                        continue;
                    }

                    Type type = PacketMapper.GetPacketType(wrapper.Type);

                    if (type == null)
                    {
                        Logger.Warning($"[UNKNOWN PACKET] From {ClientIP} Type='{wrapper.Type}' - payload size={wrapper.Payload?.Length}");
                        continue;
                    }

                    object packet = null;
                    try
                    {
                        packet = JsonSerializer.Deserialize(wrapper.Payload, type, _jsonOptions);
                    }
                    catch (Exception ex)
                    {
                        Logger.Error($"[DESERIALIZE ERROR] Failed to deserialize payload to {type.Name} from {ClientIP}", ex);
                        continue;
                    }

                    if (packet == null)
                    {
                        Logger.Warning($"[WARNING] Deserialized packet is null for type {type.Name} from {ClientIP}");
                        continue;
                    }

                    HandlePacket(packet);
                }
                catch (IOException) { break; }
                catch (Exception ex)
                {
                    Logger.Warning($"Lỗi xử lý gói tin: {ex.Message}");
                    break;
                }
            }
            Close();
        }

        public void SendPacket(object packet)
        {
            if (_stream == null || !_stream.CanWrite) return;
            try
            {
                string simpleTypeName = packet.GetType().Name;
                string payloadJson = JsonSerializer.Serialize(packet, packet.GetType(), _jsonOptions);

                var wrapper = new PacketWrapper { Type = simpleTypeName, Payload = payloadJson };
                string wrapperJson = JsonSerializer.Serialize(wrapper, _jsonOptions);

                byte[] data = Encoding.UTF8.GetBytes(wrapperJson);
                byte[] lenBuf = BitConverter.GetBytes(data.Length);

                lock (_stream)
                {
                    _stream.Write(lenBuf, 0, 4);
                    _stream.Write(data, 0, data.Length);
                    _stream.Flush();
                }
            }
            catch { Close(); }
        }

        private void HandlePacket(object packet)
        {
            switch (packet)
            {
                case LoginPacket p: HandleLogin(p); break;
                case RegisterPacket p: HandleRegister(p); break;
                case ForgotPasswordPacket p: HandleForgotPasswordRequest(p); break;
                case ResetPasswordPacket p: HandleResetPassword(p); break;
                case UpdateProfilePacket p: HandleUpdateProfile(p); break;
                case ChatHistoryRequestPacket p: HandleChatHistoryRequest(p); break;
                case RequestOnlineListPacket p: HandleRequestOnlineList(p); break;

                case TextPacket p:
                    Logger.Info($"[Chat] {p.SenderID} -> {p.ReceiverID}: {p.MessageContent}");
                    _server.RelayPrivatePacket(p.ReceiverID, p);
                    _ = Task.Run(() => DatabaseManager.Instance.SaveMessage(p.SenderID, p.ReceiverID, p.MessageContent));
                    break;

                case FilePacket p:
                    Logger.Info($"[File] {p.SenderID} -> {p.ReceiverID}: {p.FileName}");
                    _server.RelayPrivatePacket(p.ReceiverID, p);
                    _ = Task.Run(() => DatabaseManager.Instance.SaveMessage(p.SenderID, p.ReceiverID, $"Sent file: {p.FileName}", p.IsImage ? "Image" : "File", p.FileName));
                    break;

                case GameInvitePacket p:
                    Logger.Info($"[GameInvite] {p.SenderID} -> {p.ReceiverID}");
                    _server.RelayPrivatePacket(p.ReceiverID, p);
                    _ = Task.Run(() =>
                    {
                        int id = DatabaseManager.Instance.SaveMessage(p.SenderID, p.ReceiverID, "Invited to play Caro", "GameInvite", "Caro");
                        _server.StoreGameInviteMessageId(p.SenderID, p.ReceiverID, id);
                    });
                    break;

                case TankInvitePacket p:
                    Logger.Info($"[TankInvite] {p.SenderID} -> {p.ReceiverID}");
                    _server.RelayPrivatePacket(p.ReceiverID, p);
                    _ = Task.Run(() =>
                    {
                        int id = DatabaseManager.Instance.SaveMessage(p.SenderID, p.ReceiverID, "Invited to play Tank", "GameInvite", "Tank");
                        _server.StoreGameInviteMessageId(p.SenderID, p.ReceiverID, id);
                    });
                    break;

                case GameResponsePacket p: _server.ProcessGameResponse(p); break;
                case GameMovePacket p: _server.ProcessGameMove(p); break;
                case RematchRequestPacket p: _server.ProcessRematchRequest(p); break;
                case RematchResponsePacket p: _server.ProcessRematchResponse(p); break;
                case TankResponsePacket p: _server.ProcessTankResponse(p); break;
                case TankActionPacket p: _server.ProcessTankAction(p); break;
                case TankHitPacket p: _server.TankGameManager.ProcessHit(p.GameID, p.HitPlayerID, p.Damage, _server); break;

                // === GROUP CHAT ===
                case CreateGroupPacket p: HandleCreateGroup(p); break;
                case GroupTextPacket p: HandleGroupText(p); break;
                case GroupFilePacket p: HandleGroupFile(p); break;
                case GroupInvitePacket p: HandleGroupInvite(p); break;
                case LeaveGroupPacket p: HandleLeaveGroup(p); break;
                case RequestGroupListPacket p: HandleRequestGroupList(p); break;
                case GroupHistoryRequestPacket p: HandleGroupHistoryRequest(p); break;
            }
        }

        private void HandleLogin(LoginPacket p)
        {
            var user = DatabaseManager.Instance.Login(p.Username ?? p.Email, p.Password, p.UseEmailLogin);
            if (user != null)
            {
                UserID = user.Username;
                UserName = user.DisplayName;

                // === THÊM LOG ĐĂNG NHẬP Ở ĐÂY ===
                Logger.Success($"[LOGIN] User '{UserName}' ({UserID}) đã đăng nhập từ IP: {ClientIP}");

                _server.RegisterClient(UserID, this);
                
                // IMPORTANT: Delay a bit to ensure client listening thread is ready
                // Otherwise client may miss the LoginResultPacket
                System.Threading.Thread.Sleep(100);
                
                SendPacket(new LoginResultPacket { Success = true, UserID = UserID, UserName = UserName, OnlineUsers = _server.GetOnlineUsers(UserID) });
            }
            else
            {
                Logger.Warning($"[LOGIN FAIL] Đăng nhập thất bại từ IP {ClientIP} với user: {p.Username ?? p.Email}");
                SendPacket(new LoginResultPacket { Success = false, Message = "Sai tài khoản hoặc mật khẩu" });
                
                // ✅ [FIX] Chờ 500ms để client nhận được gói tin trước khi đóng kết nối
                System.Threading.Thread.Sleep(500);
                Close();
            }
        }

        private void HandleRegister(RegisterPacket p)
        {
            bool ok = DatabaseManager.Instance.RegisterUser(p.Username, p.Password, p.Email);
            if (ok) Logger.Success($"[REGISTER] Đăng ký thành công user mới: {p.Username}");
            else Logger.Warning($"[REGISTER FAIL] Đăng ký thất bại user: {p.Username}");

            SendPacket(new RegisterResultPacket { Success = ok, Message = ok ? "Success" : "User exists" });
        }

        private void HandleForgotPasswordRequest(ForgotPasswordPacket p)
        {
            if (DatabaseManager.Instance.CheckEmailExists(p.Email))
            {
                _currentOtp = new Random().Next(100000, 999999).ToString();
                _currentResetEmail = p.Email;
                _otpCreatedTime = DateTime.Now;
                bool mailSent = EmailHelper.SendOTP(p.Email, _currentOtp);
                
                if (mailSent)
                {
                    Logger.Info($"[ForgotPass] Đã gửi OTP cho email: {p.Email} - OTP: {_currentOtp}");
                    SendPacket(new ForgotPasswordResultPacket { Success = true, IsStep1Success = true, Message = "Đã gửi mã OTP. Vui lòng kiểm tra email." });
                }
                else
                {
                    Logger.Error($"[ForgotPass] Không thể gửi OTP cho email: {p.Email}");
                    SendPacket(new ForgotPasswordResultPacket { Success = false, Message = "Lỗi gửi email. Vui lòng kiểm tra cấu hình email hoặc thử lại sau." });
                    // Xóa OTP nếu gửi thất bại
                    _currentOtp = null;
                    _currentResetEmail = null;
                    _otpCreatedTime = null;
                }
            }
            else
            {
                SendPacket(new ForgotPasswordResultPacket { Success = false, Message = "Email không tồn tại trong hệ thống." });
            }
        }

        private void HandleResetPassword(ResetPasswordPacket p)
        {
            // ===== KIỂM TRA ĐẦU VÀO =====
            if (p == null)
            {
                Logger.Error("[ResetPass] ResetPasswordPacket là null");
                SendPacket(new ForgotPasswordResultPacket { Success = false, Message = "Dữ liệu không hợp lệ." });
                return;
            }

            if (string.IsNullOrWhiteSpace(p.Email))
            {
                Logger.Warning("[ResetPass] Email không được để trống");
                SendPacket(new ForgotPasswordResultPacket { Success = false, Message = "Email không được để trống." });
                return;
            }

            if (string.IsNullOrWhiteSpace(p.OtpCode))
            {
                Logger.Warning($"[ResetPass] OTP không được để trống cho email: {p.Email}");
                SendPacket(new ForgotPasswordResultPacket { Success = false, Message = "Mã OTP không được để trống." });
                return;
            }

            // Kiểm tra xem đây có phải là request verify OTP (NewPassword empty) hay đổi mật khẩu (NewPassword có giá trị)
            bool isVerifyOnly = string.IsNullOrWhiteSpace(p.NewPassword);

            // ===== KIỂM TRA 1: OTP có được tạo trước đó không =====
            if (string.IsNullOrEmpty(_currentOtp) || string.IsNullOrEmpty(_currentResetEmail))
            {
                Logger.Warning($"[ResetPass] Không có OTP nào được tạo trước đó cho email: {p.Email}");
                SendPacket(new ForgotPasswordResultPacket { Success = false, Message = "Vui lòng yêu cầu mã OTP trước." });
                return;
            }

            // ===== KIỂM TRA 2: Email có khớp với email đã yêu cầu OTP không =====
            if (!string.Equals(_currentResetEmail, p.Email, StringComparison.OrdinalIgnoreCase))
            {
                Logger.Warning($"[ResetPass] Email không khớp. Yêu cầu: {p.Email}, OTP thuộc về: {_currentResetEmail}");
                SendPacket(new ForgotPasswordResultPacket { Success = false, Message = "Email không khớp với email đã yêu cầu OTP." });
                return;
            }

            // ===== KIỂM TRA 3: OTP có hết hạn không (5 phút) =====
            if (_otpCreatedTime == null)
            {
                Logger.Warning($"[ResetPass] Thời gian tạo OTP không hợp lệ cho email: {p.Email}");
                _currentOtp = null;
                _currentResetEmail = null;
                _otpCreatedTime = null;
                SendPacket(new ForgotPasswordResultPacket { Success = false, Message = "OTP không hợp lệ. Vui lòng yêu cầu mã mới." });
                return;
            }

            double minutesSinceCreation = (DateTime.Now - _otpCreatedTime.Value).TotalMinutes;
            if (minutesSinceCreation > OTP_VALID_MINUTES)
            {
                Logger.Warning($"[ResetPass] OTP đã hết hạn cho email: {p.Email} (đã trôi qua {minutesSinceCreation:F1} phút)");
                // Xóa OTP đã hết hạn
                _currentOtp = null;
                _currentResetEmail = null;
                _otpCreatedTime = null;
                SendPacket(new ForgotPasswordResultPacket { Success = false, Message = "Mã OTP đã hết hạn. Vui lòng yêu cầu mã mới." });
                return;
            }

            // ===== KIỂM TRA 4: OTP có khớp không (so sánh chính xác) =====
            // Đảm bảo _currentOtp không null trước khi so sánh (đã kiểm tra ở trên nhưng double-check để an toàn)
            string expectedOtp = _currentOtp?.Trim() ?? string.Empty;
            string providedOtp = p.OtpCode?.Trim() ?? string.Empty;
            
            if (string.IsNullOrEmpty(expectedOtp))
            {
                Logger.Error($"[ResetPass] LỖI NGHIÊM TRỌNG: _currentOtp là null hoặc empty sau khi đã pass kiểm tra ban đầu cho email: {p.Email}");
                SendPacket(new ForgotPasswordResultPacket { Success = false, Message = "Lỗi hệ thống. Vui lòng thử lại." });
                return;
            }
            
            if (string.IsNullOrEmpty(providedOtp))
            {
                Logger.Warning($"[ResetPass] OTP được cung cấp là rỗng cho email: {p.Email}");
                SendPacket(new ForgotPasswordResultPacket { Success = false, Message = "Mã OTP không được để trống." });
                return;
            }
            
            // So sánh OTP - CHỈ KHI KHỚP MỚI CHO PHÉP ĐỔI MẬT KHẨU
            bool isOtpValid = string.Equals(expectedOtp, providedOtp, StringComparison.Ordinal);
            
            if (!isOtpValid)
            {
                Logger.Warning($"[ResetPass] OTP KHÔNG ĐÚNG cho email: {p.Email}. Nhập: '{providedOtp}', Đúng: '{expectedOtp}'");
                SendPacket(new ForgotPasswordResultPacket { Success = false, Message = "Mã OTP không đúng. Vui lòng kiểm tra lại." });
                return; // QUAN TRỌNG: Return ngay lập tức, KHÔNG được đổi mật khẩu
            }

            // ===== CHỈ KHI TẤT CẢ KIỂM TRA ĐỀU PASS - MỚI ĐƯỢC PHÉP ĐỔI MẬT KHẨU =====
            // Đảm bảo OTP đã được xác minh trước khi gọi UpdatePassword
            // Double-check: Nếu OTP không hợp lệ, KHÔNG BAO GIỜ được gọi UpdatePassword
            if (!isOtpValid)
            {
                Logger.Error($"[ResetPass] LỖI BẢO MẬT: Cố gắng đổi mật khẩu với OTP không hợp lệ cho email: {p.Email}");
                SendPacket(new ForgotPasswordResultPacket { Success = false, Message = "Lỗi xác thực. Vui lòng thử lại." });
                return;
            }
            
            // ===== OTP ĐÃ ĐƯỢC XÁC MINH THÀNH CÔNG =====
            if (isVerifyOnly)
            {
                // Chỉ verify OTP, không đổi mật khẩu
                Logger.Info($"[ResetPass] OTP đã được xác minh thành công cho email: {p.Email} (chỉ verify, chưa đổi mật khẩu)");
                SendPacket(new ForgotPasswordResultPacket { Success = true, IsStep1Success = false, Message = "OTP verified successfully" });
                // KHÔNG xóa OTP ở đây vì user chưa đổi mật khẩu, cần giữ OTP để dùng khi đổi mật khẩu
            }
            else
            {
                // Verify OTP và đổi mật khẩu
                Logger.Info($"[ResetPass] OTP đã được xác minh thành công cho email: {p.Email}. Tiến hành đổi mật khẩu...");
                
                try
                {
                    // CHỈ GỌI UpdatePassword KHI OTP ĐÃ ĐƯỢC XÁC MINH THÀNH CÔNG VÀ CÓ MẬT KHẨU MỚI
                    DatabaseManager.Instance.UpdatePassword(p.Email, p.NewPassword);
                    Logger.Success($"[ResetPass] Đổi mật khẩu thành công cho email: {p.Email}");
                    
                    // Xóa OTP sau khi sử dụng thành công để tránh tái sử dụng
                    _currentOtp = null;
                    _currentResetEmail = null;
                    _otpCreatedTime = null;
                    
                    SendPacket(new ForgotPasswordResultPacket { Success = true, IsStep1Success = false, Message = "Password Changed" });
                }
                catch (Exception ex)
                {
                    Logger.Error($"[ResetPass] Lỗi khi đổi mật khẩu cho email: {p.Email}", ex);
                    SendPacket(new ForgotPasswordResultPacket { Success = false, Message = "Lỗi hệ thống khi đổi mật khẩu. Vui lòng thử lại sau." });
                }
            }
        }

        private void HandleUpdateProfile(UpdateProfilePacket p)
        {
            DatabaseManager.Instance.UpdateDisplayName(p.UserID, p.NewDisplayName);
            this.UserName = p.NewDisplayName;
            Logger.Info($"[Profile] User {UserID} đổi tên thành: {p.NewDisplayName}");
            _server.BroadcastPacket(p, null);
        }

        private void HandleChatHistoryRequest(ChatHistoryRequestPacket p)
        {
            var dbMessages = DatabaseManager.Instance.GetChatHistory(p.UserID, p.FriendID, p.Limit);
            var sharedMessages = dbMessages.Select(m => new ChatHistoryMessage
            {
                MessageID = m.MessageID,
                SenderID = m.SenderID ?? "",
                ReceiverID = m.ReceiverID ?? "",
                MessageContent = m.MessageContent ?? "",
                MessageType = m.MessageType,
                FileName = m.FileName,
                CreatedAt = m.CreatedAt
            }).ToList();

            var response = new ChatHistoryResponsePacket { Success = true, Message = "OK", Messages = sharedMessages };
            SendPacket(response);
        }

        private void HandleRequestOnlineList(RequestOnlineListPacket p)
        {
            SendPacket(new OnlineListPacket { OnlineUsers = _server.GetOnlineUsers(UserID) });
        }

        // =====================================================
        // === XỬ LÝ NHÓM CHAT ===
        // =====================================================

        private void HandleCreateGroup(CreateGroupPacket p)
        {
            Logger.Info($"[Group] {p.CreatorID} tạo nhóm '{p.GroupName}' với {p.MemberIDs.Count} thành viên");
            
            string groupId = DatabaseManager.Instance.CreateGroup(p.GroupName, p.CreatorID, p.MemberIDs);
            
            if (string.IsNullOrEmpty(groupId))
            {
                SendPacket(new CreateGroupResultPacket { Success = false, Message = "Không thể tạo nhóm" });
                return;
            }
            
            var members = DatabaseManager.Instance.GetGroupMembers(groupId);
            
            // Gửi kết quả cho người tạo
            SendPacket(new CreateGroupResultPacket 
            { 
                Success = true, 
                GroupID = groupId, 
                GroupName = p.GroupName,
                Members = members
            });
            
            // Thông báo cho các thành viên khác
            var notification = new GroupInviteNotificationPacket
            {
                GroupID = groupId,
                GroupName = p.GroupName,
                InviterName = UserName,
                Members = members
            };
            
            foreach (var memberId in p.MemberIDs)
            {
                if (memberId != p.CreatorID)
                {
                    _server.RelayPrivatePacket(memberId, notification);
                }
            }
        }

        private void HandleGroupText(GroupTextPacket p)
        {
            Logger.Info($"[Group] {p.SenderID} -> Nhóm {p.GroupID}: {p.MessageContent}");
            
            // Lưu tin nhắn vào DB
            _ = Task.Run(() => DatabaseManager.Instance.SaveGroupMessage(p.GroupID, p.SenderID, p.MessageContent, "Text"));
            
            // Lấy danh sách thành viên và gửi tin nhắn cho tất cả (trừ người gửi)
            var members = DatabaseManager.Instance.GetGroupMembers(p.GroupID);
            p.SenderName = UserName; // Đảm bảo có tên người gửi
            p.SentAt = DateTime.Now;
            
            foreach (var member in members)
            {
                if (member.UserID != p.SenderID)
                {
                    _server.RelayPrivatePacket(member.UserID, p);
                }
            }
        }

        private void HandleGroupFile(GroupFilePacket p)
        {
            Logger.Info($"[Group] File từ {p.SenderID} -> Nhóm {p.GroupID}: {p.FileName}");
            
            // Lưu thông tin file vào DB
            string type = p.IsImage ? "Image" : "File";
            _ = Task.Run(() => DatabaseManager.Instance.SaveGroupMessage(p.GroupID, p.SenderID, $"Sent {type}: {p.FileName}", type, p.FileName));
            
            // Gửi cho tất cả thành viên
            var members = DatabaseManager.Instance.GetGroupMembers(p.GroupID);
            p.SenderName = UserName;
            
            foreach (var member in members)
            {
                if (member.UserID != p.SenderID)
                {
                    _server.RelayPrivatePacket(member.UserID, p);
                }
            }
        }

        private void HandleGroupInvite(GroupInvitePacket p)
        {
            Logger.Info($"[Group] {p.InviterID} mời {p.InviteeIDs.Count} người vào nhóm {p.GroupID}");
            
            var members = DatabaseManager.Instance.GetGroupMembers(p.GroupID);
            
            foreach (var inviteeId in p.InviteeIDs)
            {
                // Thêm vào DB
                if (DatabaseManager.Instance.AddGroupMember(p.GroupID, inviteeId))
                {
                    // Thông báo cho người được mời
                    var notification = new GroupInviteNotificationPacket
                    {
                        GroupID = p.GroupID,
                        GroupName = p.GroupName,
                        InviterName = UserName,
                        Members = DatabaseManager.Instance.GetGroupMembers(p.GroupID)
                    };
                    _server.RelayPrivatePacket(inviteeId, notification);
                    
                    // Thông báo cho các thành viên cũ
                    var memberUpdate = new GroupMemberUpdatePacket
                    {
                        GroupID = p.GroupID,
                        UserID = inviteeId,
                        UserName = DatabaseManager.Instance.GetDisplayName(inviteeId),
                        Joined = true
                    };
                    
                    foreach (var member in members)
                    {
                        _server.RelayPrivatePacket(member.UserID, memberUpdate);
                    }
                }
            }
        }

        private void HandleLeaveGroup(LeaveGroupPacket p)
        {
            Logger.Info($"[Group] {p.UserID} rời nhóm {p.GroupID}");
            
            var members = DatabaseManager.Instance.GetGroupMembers(p.GroupID);
            
            if (DatabaseManager.Instance.RemoveGroupMember(p.GroupID, p.UserID))
            {
                // Thông báo cho các thành viên còn lại
                var memberUpdate = new GroupMemberUpdatePacket
                {
                    GroupID = p.GroupID,
                    UserID = p.UserID,
                    UserName = UserName,
                    Joined = false
                };
                
                foreach (var member in members)
                {
                    if (member.UserID != p.UserID)
                    {
                        _server.RelayPrivatePacket(member.UserID, memberUpdate);
                    }
                }
            }
        }

        private void HandleRequestGroupList(RequestGroupListPacket p)
        {
            var groups = DatabaseManager.Instance.GetUserGroups(p.UserID);
            SendPacket(new GroupListPacket { Groups = groups });
        }

        private void HandleGroupHistoryRequest(GroupHistoryRequestPacket p)
        {
            // Kiểm tra quyền truy cập
            if (!DatabaseManager.Instance.IsGroupMember(p.GroupID, p.UserID))
            {
                SendPacket(new GroupHistoryResponsePacket { Success = false, GroupID = p.GroupID });
                return;
            }
            
            var messages = DatabaseManager.Instance.GetGroupHistory(p.GroupID, p.Limit);
            SendPacket(new GroupHistoryResponsePacket 
            { 
                Success = true, 
                GroupID = p.GroupID,
                Messages = messages 
            });
        }

        public void Close()
        {
            if (UserID != null)
            {
                Logger.Warning($"[LOGOUT] User '{UserName}' ({UserID}) đã ngắt kết nối.");
                _server.RemoveClient(UserID);
            }
            _client?.Close();
        }

        // Đóng kết nối mà không gọi RemoveClient (dùng khi client bị thay thế bởi client mới)
        public void CloseConnectionOnly()
        {
            _client?.Close();
        }
    }
}